#pragma once

#include <include/list.h>
#include <include/stdio.h>
#include <include/device.h>

#define I2C_NAME_SIZE		10


#define I2C_FLAGS_DATA_1BYTE		(0x01)
#define I2C_FLAGS_DATA_2BYTE		(0x02)
#define I2C_FLAGS_DATA_3BYTE		(0x03)
#define I2C_FLAGS_DATA_4BYTE		(0x04)

#define I2C_FLAGS_WRITE_DIRECTLY	(0x01 << 4)
#define I2C_FLAGS_WRITE_INDIRECTLY	(0x00 << 4)

/**
 * struct i2c_board_info - template for device creation
 * @type: chip type, to initialize i2c_client.name
 * @flags: to initialize i2c_client.flags
 * @addr: stored in i2c_client.addr
 * @platform_data: stored in i2c_client.dev.platform_data
 * @archdata: copied into i2c_client.dev.archdata
 * @of_node: pointer to OpenFirmware device node
 * @acpi_node: ACPI device node
 * @irq: stored in i2c_client.irq
 *
 * I2C doesn't actually support hardware probing, although controllers and
 * devices may be able to use I2C_SMBUS_QUICK to tell whether or not there's
 * a device at a given address.  Drivers commonly need more information than
 * that, such as chip type, configuration, associated IRQ, and so on.
 *
 * i2c_board_info is used to build tables of information listing I2C devices
 * that are present.  This information is used to grow the driver model tree.
 * For mainboards this is done statically using i2c_register_board_info();
 * bus numbers identify adapters that aren't yet available.  For add-on boards,
 * i2c_new_device() does this dynamically with the adapter already known.
 */
struct i2c_board_info {
	char		type[I2C_NAME_SIZE];
	unsigned short	flags;
	unsigned short	addr;
	//void		*platform_data;
	//struct dev_archdata	*archdata;
	//struct device_node *of_node;
	//struct acpi_dev_node acpi_node;
	unsigned char	irq;
};

/**
 * I2C_BOARD_INFO - macro used to list an i2c device and its address
 * @dev_type: identifies the device type
 * @dev_addr: the device's address on the bus.
 *
 * This macro initializes essential fields of a struct i2c_board_info,
 * declaring what has been provided on a particular board.  Optional
 * fields (such as associated irq, or device-specific platform_data)
 * are provided using conventional syntax.
 */
#define I2C_BOARD_INFO(dev_type, dev_flags, dev_addr) \
	.type = dev_type, .flags = dev_flags, .addr = (dev_addr)

#define pr_debug	printk
#define pr_warn		printk

struct i2c_devinfo {
	struct list_head	list;
	int			busnum;
	struct i2c_board_info	board_info;
};

/* use a define to avoid include chaining to get THIS_MODULE */
#define i2c_add_driver(driver) \
	i2c_register_driver(THIS_MODULE, driver)

struct i2c_config {
	__u8  	bus_num;
    __u8 	scl;
    __u8 	sda;
    __u32 	freq;
};

extern struct i2c_client;
struct i2c_bus_info {
	const struct i2c_config *confg;
	struct list_head	list;

	int (*prode)(void);
	int (*i2c_transfer)(struct i2c_client *client, unsigned int cmd, __u8 addr, __u32 *value);
};

/**
 * struct i2c_client - represent an I2C slave device
 * @flags: I2C_CLIENT_TEN indicates the device uses a ten bit chip address;
 *	I2C_CLIENT_PEC indicates it uses SMBus Packet Error Checking
 * @addr: Address used on the I2C bus connected to the parent adapter.
 * @name: Indicates the type of the device, usually a chip name that's
 *	generic enough to hide second-sourcing and compatible revisions.
 * @adapter: manages the bus segment hosting this I2C device
 * @driver: device's driver, hence pointer to access routines
 * @dev: Driver model device node for the slave.
 * @irq: indicates the IRQ generated by this device (if any)
 * @detected: member of an i2c_driver.clients list or i2c-core's
 *	userspace_devices list
 *
 * An i2c_client identifies a single device (i.e. chip) connected to an
 * i2c bus. The behaviour exposed to Linux is defined by the driver
 * managing the device.
 */
struct i2c_client {
	//unsigned short flags;		/* div., see below		*/
	//unsigned short addr;		/* chip address - NOTE: 7bit	*/
					/* addresses are stored in the	*/
					/* _LOWER_ 7 bits		*/
	//char name[I2C_NAME_SIZE];
	//struct i2c_adapter *adapter;	/* the adapter we sit on	*/
	//struct i2c_driver *driver;	/* and our access routines	*/
	//struct device dev;		/* the device structure		*/
	//int irq;			/* irq issued by device		*/
	//struct list_head detected;
#ifdef USE_I2C_MTK_EXT
	__u32 timing;			/* paramters of timings		*/
	__u32 ext_flag;
#endif
	struct i2c_devinfo dev_info;
	struct i2c_bus_info *bus_info;
};

enum i2c_cmd {
	I2C_CMD_WRITE = 1,
	I2C_CMD_READ,
	I2C_BUS_RESET,
	I2C_CMD_MAX
};

/**
 * struct i2c_driver - represent an I2C device driver
 * @class: What kind of i2c device we instantiate (for detect)
 * @attach_adapter: Callback for bus addition (deprecated)
 * @probe: Callback for device binding
 * @remove: Callback for device unbinding
 * @shutdown: Callback for device shutdown
 * @suspend: Callback for device suspend
 * @resume: Callback for device resume
 * @alert: Alert callback, for example for the SMBus alert protocol
 * @command: Callback for bus-wide signaling (optional)
 * @driver: Device driver model driver
 * @id_table: List of I2C devices supported by this driver
 * @detect: Callback for device detection
 * @address_list: The I2C addresses to probe (for detect)
 * @clients: List of detected clients we created (for i2c-core use only)
 *
 * The driver.owner field should be set to the module owner of this driver.
 * The driver.name field should be set to the name of this driver.
 *
 * For automatic device detection, both @detect and @address_list must
 * be defined. @class should also be set, otherwise only devices forced
 * with module parameters will be created. The detect function must
 * fill at least the name field of the i2c_board_info structure it is
 * handed upon successful detection, and possibly also the flags field.
 *
 * If @detect is missing, the driver will still work fine for enumerated
 * devices. Detected devices simply won't be supported. This is expected
 * for the many I2C/SMBus devices which can't be detected reliably, and
 * the ones which can always be enumerated in practice.
 *
 * The i2c_client structure which is handed to the @detect callback is
 * not a real i2c_client. It is initialized just enough so that you can
 * call i2c_smbus_read_byte_data and friends on it. Don't do anything
 * else with it. In particular, calling dev_dbg and friends on it is
 * not allowed.
 */
struct i2c_driver {
	//unsigned int class;

	/* Notifies the driver that a new bus has appeared. You should avoid
	 * using this, it will be removed in a near future.
	 */
	//int (*attach_adapter)(struct i2c_adapter *) __deprecated;

	/* Standard driver model interfaces */
	//int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);

	/* driver model interfaces that don't relate to enumeration  */
	void (*shutdown)(struct i2c_client *);
	//int (*suspend)(struct i2c_client *, pm_message_t mesg);
	int (*resume)(struct i2c_client *);

	/* Alert callback, for example for the SMBus alert protocol.
	 * The format and meaning of the data value depends on the protocol.
	 * For the SMBus alert protocol, there is a single bit of data passed
	 * as the alert response's low bit ("event flag").
	 */
	//void (*alert)(struct i2c_client *, unsigned int data);

	/* a ioctl like command that can be used to perform specific functions
	 * with the device.
	 */
	//int (*command)(struct i2c_client *client, unsigned int cmd, void *arg);

	//struct device_driver driver;
	struct driver driver;
	//const struct i2c_device_id *id_table;

	/* Device detection callback for automatic device creation */
	//int (*detect)(struct i2c_client *, struct i2c_board_info *);
	//const unsigned short *address_list;
	struct list_head clients;
};
#define to_i2c_driver(d) container_of(d, struct i2c_driver, driver)


extern int driver_register(struct driver *drv);
struct i2c_client *
i2c_register_board_info(int busnum,
		struct i2c_board_info const *info, unsigned len);
struct i2c_bus_info *
		i2c_match_businfo(struct i2c_client *client);